import { BytesList } from '../serdes/binary-serializer';
import { BinaryParser } from '../serdes/binary-parser';
import { XrplDefinitionsBase } from '../enums';
/**
 * Enum for SerializedTypeID values used in XRPL
 * These match the C++ implementation's STI_ constants
 */
export declare enum SerializedTypeID {
    STI_NOTPRESENT = 0,
    STI_UINT16 = 1,
    STI_UINT32 = 2,
    STI_UINT64 = 3,
    STI_UINT128 = 4,
    STI_UINT256 = 5,
    STI_AMOUNT = 6,
    STI_VL = 7,
    STI_ACCOUNT = 8,
    STI_NUMBER = 9,
    STI_INT32 = 10,
    STI_INT64 = 11,
    STI_OBJECT = 14,
    STI_ARRAY = 15,
    STI_UINT8 = 16,
    STI_UINT160 = 17,
    STI_PATHSET = 18,
    STI_VECTOR256 = 19,
    STI_UINT96 = 20,
    STI_UINT192 = 21,
    STI_UINT384 = 22,
    STI_UINT512 = 23,
    STI_ISSUE = 24,
    STI_XCHAIN_BRIDGE = 25,
    STI_CURRENCY = 26,
    STI_DATA = 27,
    STI_DATATYPE = 28,
    STI_JSON = 29
}
/**
 * Map of type strings to SerializedTypeID values
 */
export declare const TYPE_STRING_TO_ID: Record<string, SerializedTypeID>;
/**
 * Map of type strings to SerializedTypeID values
 */
export declare const TYPE_NUMBER_TO_ID: Record<number, SerializedTypeID>;
/**
 * Map of SerializedTypeID values to type strings
 */
export declare const TYPE_ID_TO_STRING: Record<SerializedTypeID, string>;
type JSON = string | number | boolean | null | undefined | JSON[] | JsonObject;
type JsonObject = {
    [key: string]: JSON;
};
/**
 * The base class for all binary-codec types
 */
declare class SerializedType {
    protected readonly bytes: Uint8Array;
    constructor(bytes?: Uint8Array);
    static fromParser(parser: BinaryParser, hint?: number): SerializedType;
    static from(value: SerializedType | JSON | bigint): SerializedType;
    /**
     * Write the bytes representation of a SerializedType to a BytesList
     *
     * @param list The BytesList to write SerializedType bytes to
     */
    toBytesSink(list: BytesList): void;
    /**
     * Get the hex representation of a SerializedType's bytes
     *
     * @returns hex String of this.bytes
     */
    toHex(): string;
    /**
     * Get the bytes representation of a SerializedType
     *
     * @returns A Uint8Array of the bytes
     */
    toBytes(): Uint8Array;
    /**
     * Return the JSON representation of a SerializedType
     *
     * @param _definitions rippled definitions used to parse the values of transaction types and such.
     *                          Unused in default, but used in STObject, STArray
     *                          Can be customized for sidechains and amendments.
     * @returns any type, if not overloaded returns hexString representation of bytes
     */
    toJSON(_definitions?: XrplDefinitionsBase, _fieldName?: string): JSON;
    /**
     * @returns hexString representation of this.bytes
     */
    toString(): string;
    getSType(): SerializedTypeID;
}
/**
 * Base class for SerializedTypes that are comparable.
 *
 * @template T - What types you want to allow comparisons between. You must specify all types. Primarily used to allow
 * comparisons between built-in types (like `string`) and SerializedType subclasses (like `Hash`).
 *
 * Ex. `class Hash extends Comparable<Hash | string>`
 */
declare class Comparable<T extends Object> extends SerializedType {
    lt(other: T): boolean;
    eq(other: T): boolean;
    gt(other: T): boolean;
    gte(other: T): boolean;
    lte(other: T): boolean;
    /**
     * Overload this method to define how two Comparable SerializedTypes are compared
     *
     * @param other The comparable object to compare this to
     * @returns A number denoting the relationship of this and other
     */
    compareTo(other: T): number;
}
export { SerializedType, Comparable, JSON, JsonObject };
