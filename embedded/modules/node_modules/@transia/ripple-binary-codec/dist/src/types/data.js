"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Data = void 0;
/* eslint-disable max-lines */
/* eslint-disable complexity */
const binary_parser_1 = require("../serdes/binary-parser");
const serialized_type_1 = require("./serialized-type");
const utils_1 = require("../utils");
const utils_2 = require("@transia/isomorphic/utils");
const hash_128_1 = require("./hash-128");
const hash_160_1 = require("./hash-160");
const hash_192_1 = require("./hash-192");
const hash_256_1 = require("./hash-256");
const account_id_1 = require("./account-id");
const amount_1 = require("./amount");
const blob_1 = require("./blob");
const currency_1 = require("./currency");
const st_number_1 = require("./st-number");
const issue_1 = require("./issue");
const uint_8_1 = require("./uint-8");
const uint_16_1 = require("./uint-16");
const uint_32_1 = require("./uint-32");
const uint_64_1 = require("./uint-64");
const binary_1 = require("../binary");
/**
 * STData: Encodes XRPL's "Data" type.
 *
 * This type wraps both a SerializedTypeID and the actual data value.
 * It's encoded as a 2-byte type ID followed by the serialized data.
 *
 * Usage:
 *   Data.from({ type: "AMOUNT", value: "1000000" })
 *   Data.from({ type: "UINT64", value: "123456789" })
 *   Data.fromParser(parser)
 */
class Data extends serialized_type_1.SerializedType {
    /**
     * Construct Data from bytes
     * @param bytes - Uint8Array containing type ID and data
     */
    constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : Data.ZERO_DATA.bytes);
    }
    /**
     * Create Data from various input types
     *
     * @param value - Can be:
     *   - Data instance (returns as-is)
     *   - DataJSON object with 'type' and 'value' fields
     * @returns Data instance
     * @throws Error if value type is not supported
     */
    static from(value) {
        if (value instanceof Data) {
            return value;
        }
        if (typeof value === 'object' &&
            value !== null &&
            'type' in value &&
            'value' in value) {
            const json = value;
            return Data.fromJSON(json);
        }
        throw new Error('Data.from: value must be Data instance or DataJSON object');
    }
    /**
     * Create Data from JSON representation
     *
     * @param json - Object with 'type' and 'value' fields
     * @returns Data instance
     * @throws Error if type is not supported
     */
    static fromJSON(json) {
        const typeId = serialized_type_1.TYPE_STRING_TO_ID[json.type];
        if (typeId === undefined) {
            throw new Error(`Data: unsupported type string: ${json.type}`);
        }
        let dataValue;
        let dataBytes;
        switch (typeId) {
            case serialized_type_1.SerializedTypeID.STI_UINT8: {
                const val = typeof json.value === 'string'
                    ? parseInt(json.value, 10)
                    : typeof json.value === 'number'
                        ? json.value
                        : Number(json.value);
                if (typeof val !== 'number' ||
                    Number.isNaN(val) ||
                    val < 0 ||
                    val > 255) {
                    throw new Error('UINT8 value out of range');
                }
                dataValue = uint_8_1.UInt8.from(val);
                dataBytes = dataValue.toBytes();
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_UINT16: {
                const val = typeof json.value === 'string'
                    ? parseInt(json.value, 10)
                    : typeof json.value === 'number'
                        ? json.value
                        : Number(json.value);
                if (typeof val !== 'number' ||
                    Number.isNaN(val) ||
                    val < 0 ||
                    val > 65535) {
                    throw new Error('UINT16 value out of range');
                }
                dataValue = uint_16_1.UInt16.from(val);
                dataBytes = dataValue.toBytes();
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_UINT32: {
                const val = typeof json.value === 'string'
                    ? parseInt(json.value, 10)
                    : typeof json.value === 'number'
                        ? json.value
                        : Number(json.value);
                dataValue = uint_32_1.UInt32.from(val);
                dataBytes = dataValue.toBytes();
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_UINT64: {
                const val = typeof json.value === 'string' ? json.value : json.value.toString();
                dataValue = uint_64_1.UInt64.from(val);
                dataBytes = dataValue.toBytes();
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_UINT128: {
                const val = typeof json.value === 'string' ? json.value : json.value.toString();
                dataValue = hash_128_1.Hash128.from(val);
                dataBytes = dataValue.toBytes();
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_UINT160: {
                const val = typeof json.value === 'string' ? json.value : json.value.toString();
                dataValue = hash_160_1.Hash160.from(val);
                dataBytes = dataValue.toBytes();
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_UINT192: {
                const val = typeof json.value === 'string' ? json.value : json.value.toString();
                dataValue = hash_192_1.Hash192.from(val);
                dataBytes = dataValue.toBytes();
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_UINT256: {
                const val = typeof json.value === 'string' ? json.value : json.value.toString();
                dataValue = hash_256_1.Hash256.from(val);
                dataBytes = dataValue.toBytes();
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_VL: {
                const val = typeof json.value === 'string' ? json.value : json.value.toString();
                dataValue = blob_1.Blob.from(val);
                dataBytes = dataValue.toBytes();
                const lengthBytes = binary_1.BinarySerializer.encodeVariableLength(dataBytes.length);
                dataBytes = (0, utils_2.concat)([lengthBytes, dataBytes]);
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_ACCOUNT: {
                dataValue = account_id_1.AccountID.from(typeof json.value === 'string' ? json.value : json.value.toString());
                dataBytes = dataValue.toBytes();
                dataBytes = (0, utils_2.concat)([new Uint8Array([0x14]), dataBytes]);
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_AMOUNT: {
                dataValue = amount_1.Amount.from(json.value);
                dataBytes = dataValue.toBytes();
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_ISSUE: {
                dataValue = issue_1.Issue.from(json.value);
                dataBytes = dataValue.toBytes();
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_CURRENCY: {
                const val = typeof json.value === 'string' ? json.value : json.value.toString();
                dataValue = currency_1.Currency.from(val);
                dataBytes = dataValue.toBytes();
                break;
            }
            case serialized_type_1.SerializedTypeID.STI_NUMBER: {
                dataValue = st_number_1.STNumber.from(json.value);
                dataBytes = dataValue.toBytes();
                break;
            }
            default:
                throw new Error(`Data.fromJSON(): unsupported type ID: ${typeId}`);
        }
        // Combine type header with data bytes
        const typeBytes = new Uint8Array(2);
        (0, utils_1.writeUInt16BE)(typeBytes, typeId, 0);
        const fullBytes = (0, utils_2.concat)([typeBytes, dataBytes]);
        return new Data(fullBytes);
    }
    /**
     * Read Data from a BinaryParser stream
     *
     * @param parser - BinaryParser positioned at the start of Data
     * @returns Data instance
     */
    static fromParser(parser) {
        // Read the 2-byte type ID
        const typeBytes = parser.read(2);
        const typeId = serialized_type_1.TYPE_NUMBER_TO_ID[(0, utils_1.readUInt16BE)(typeBytes, 0)];
        let dataValue;
        let dataBytes;
        switch (typeId) {
            case serialized_type_1.SerializedTypeID.STI_UINT8:
                dataValue = uint_8_1.UInt8.fromParser(parser);
                dataBytes = dataValue.toBytes();
                break;
            case serialized_type_1.SerializedTypeID.STI_UINT16:
                dataValue = uint_16_1.UInt16.fromParser(parser);
                dataBytes = dataValue.toBytes();
                break;
            case serialized_type_1.SerializedTypeID.STI_UINT32:
                dataValue = uint_32_1.UInt32.fromParser(parser);
                dataBytes = dataValue.toBytes();
                break;
            case serialized_type_1.SerializedTypeID.STI_UINT64:
                dataValue = uint_64_1.UInt64.fromParser(parser);
                dataBytes = dataValue.toBytes();
                break;
            case serialized_type_1.SerializedTypeID.STI_UINT128:
                dataValue = hash_128_1.Hash128.fromParser(parser);
                dataBytes = dataValue.toBytes();
                break;
            case serialized_type_1.SerializedTypeID.STI_UINT160:
                dataValue = hash_160_1.Hash160.fromParser(parser);
                dataBytes = dataValue.toBytes();
                break;
            case serialized_type_1.SerializedTypeID.STI_UINT192:
                dataValue = hash_192_1.Hash192.fromParser(parser);
                dataBytes = dataValue.toBytes();
                break;
            case serialized_type_1.SerializedTypeID.STI_UINT256:
                dataValue = hash_256_1.Hash256.fromParser(parser);
                dataBytes = dataValue.toBytes();
                break;
            case serialized_type_1.SerializedTypeID.STI_VL:
                const valueVL = parser.readVariableLength();
                dataValue = blob_1.Blob.from((0, utils_2.bytesToHex)(valueVL));
                dataBytes = (0, utils_2.concat)([
                    binary_1.BinarySerializer.encodeVariableLength(valueVL.length),
                    valueVL,
                ]);
                break;
            case serialized_type_1.SerializedTypeID.STI_ACCOUNT:
                parser.skip(1);
                dataValue = account_id_1.AccountID.fromParser(parser);
                dataBytes = (0, utils_2.concat)([
                    new Uint8Array([0x14]),
                    dataValue.toBytes(),
                ]);
                break;
            case serialized_type_1.SerializedTypeID.STI_AMOUNT:
                dataValue = amount_1.Amount.fromParser(parser);
                dataBytes = dataValue.toBytes();
                break;
            case serialized_type_1.SerializedTypeID.STI_ISSUE:
                dataValue = issue_1.Issue.fromParser(parser);
                dataBytes = dataValue.toBytes();
                break;
            case serialized_type_1.SerializedTypeID.STI_CURRENCY:
                dataValue = currency_1.Currency.fromParser(parser);
                dataBytes = dataValue.toBytes();
                break;
            case serialized_type_1.SerializedTypeID.STI_NUMBER:
                dataValue = st_number_1.STNumber.fromParser(parser);
                dataBytes = dataValue.toBytes();
                break;
            default:
                throw new Error(`Data: unsupported type ID when parsing: ${typeId}`);
        }
        const fullBytes = (0, utils_2.concat)([typeBytes, dataBytes]);
        return new Data(fullBytes);
    }
    /**
     * Get the inner SerializedTypeID
     *
     * @returns The inner type ID
     */
    getInnerType() {
        return serialized_type_1.TYPE_NUMBER_TO_ID[(0, utils_1.readUInt16BE)(this.bytes, 0)];
    }
    /**
     * Get the string representation of the inner type
     *
     * @returns String name of the type
     */
    getInnerTypeString() {
        const innerType = this.getInnerType();
        return serialized_type_1.TYPE_ID_TO_STRING[innerType] || innerType.toString();
    }
    /**
     * Get the data value
     *
     * @returns The stored data value
     */
    getValue() {
        const innerType = this.getInnerType();
        const parser = new binary_parser_1.BinaryParser((0, utils_2.bytesToHex)(this.bytes.slice(2)));
        switch (innerType) {
            case serialized_type_1.SerializedTypeID.STI_UINT8:
                return uint_8_1.UInt8.fromParser(parser);
            case serialized_type_1.SerializedTypeID.STI_UINT16:
                return uint_16_1.UInt16.fromParser(parser);
            case serialized_type_1.SerializedTypeID.STI_UINT32:
                return uint_32_1.UInt32.fromParser(parser);
            case serialized_type_1.SerializedTypeID.STI_UINT64:
                return uint_64_1.UInt64.fromParser(parser);
            case serialized_type_1.SerializedTypeID.STI_UINT128:
                return hash_128_1.Hash128.fromParser(parser);
            case serialized_type_1.SerializedTypeID.STI_UINT160:
                return hash_160_1.Hash160.fromParser(parser);
            case serialized_type_1.SerializedTypeID.STI_UINT192:
                return hash_192_1.Hash192.fromParser(parser);
            case serialized_type_1.SerializedTypeID.STI_UINT256:
                return hash_256_1.Hash256.fromParser(parser);
            case serialized_type_1.SerializedTypeID.STI_VL:
                const vlLength = parser.readVariableLengthLength();
                return blob_1.Blob.fromParser(parser, vlLength);
            case serialized_type_1.SerializedTypeID.STI_ACCOUNT:
                parser.skip(1);
                return account_id_1.AccountID.fromParser(parser);
            case serialized_type_1.SerializedTypeID.STI_AMOUNT:
                return amount_1.Amount.fromParser(parser);
            case serialized_type_1.SerializedTypeID.STI_ISSUE:
                return issue_1.Issue.fromParser(parser);
            case serialized_type_1.SerializedTypeID.STI_CURRENCY:
                return currency_1.Currency.fromParser(parser);
            case serialized_type_1.SerializedTypeID.STI_NUMBER:
                return st_number_1.STNumber.fromParser(parser);
            default:
                throw new Error(`Data.getValue(): unsupported type ID: ${typeof innerType}`);
        }
    }
    /**
     * Convert to JSON representation
     *
     * @returns JSON object with 'type' and 'value' fields
     */
    toJSON() {
        const data = this.getValue();
        let jsonValue;
        // Convert the data value to its JSON representation
        if (data instanceof serialized_type_1.SerializedType) {
            jsonValue = data.toJSON();
        }
        else if (data instanceof Uint8Array) {
            jsonValue = (0, utils_2.bytesToHex)(data);
        }
        else if (typeof data === 'bigint') {
            jsonValue = data.toString();
        }
        else {
            jsonValue = data;
        }
        return {
            type: this.getInnerTypeString(),
            value: jsonValue,
        };
    }
    /**
     * Compare with another Data for equality
     *
     * @param other - Another Data to compare with
     * @returns true if both have the same inner type and data
     */
    equals(other) {
        if (!(other instanceof Data)) {
            return false;
        }
        // Compare bytes directly
        if (this.bytes.length !== other.bytes.length) {
            return false;
        }
        for (let i = 0; i < this.bytes.length; i++) {
            if (this.bytes[i] !== other.bytes[i]) {
                return false;
            }
        }
        return true;
    }
    getSType() {
        return serialized_type_1.SerializedTypeID.STI_DATA;
    }
}
exports.Data = Data;
Data.ZERO_DATA = new Data((0, utils_2.concat)([
    new Uint8Array([0x00, 0x01]),
    new Uint8Array([0x00, 0x00]), // Value: two zero bytes for UINT16
]));
//# sourceMappingURL=data.js.map