import { BinaryParser } from '../serdes/binary-parser';
import { JsonObject, SerializedType, SerializedTypeID } from './serialized-type';
import { Hash128 } from './hash-128';
import { Hash160 } from './hash-160';
import { Hash192 } from './hash-192';
import { Hash256 } from './hash-256';
import { AccountID } from './account-id';
import { Amount } from './amount';
import { Blob } from './blob';
import { Currency } from './currency';
import { STNumber } from './st-number';
import { Issue } from './issue';
import { UInt8 } from './uint-8';
import { UInt16 } from './uint-16';
import { UInt32 } from './uint-32';
import { UInt64 } from './uint-64';
/**
 * Interface for Data JSON representation
 */
interface DataJSON extends JsonObject {
    type: string;
    value: string | number | JsonObject;
}
/**
 * Type union for all possible data values
 */
type DataValue = number | string | bigint | Uint8Array | UInt8 | UInt16 | UInt32 | UInt64 | Hash128 | Hash160 | Hash192 | Hash256 | AccountID | Amount | Blob | Currency | STNumber | Issue;
/**
 * STData: Encodes XRPL's "Data" type.
 *
 * This type wraps both a SerializedTypeID and the actual data value.
 * It's encoded as a 2-byte type ID followed by the serialized data.
 *
 * Usage:
 *   Data.from({ type: "AMOUNT", value: "1000000" })
 *   Data.from({ type: "UINT64", value: "123456789" })
 *   Data.fromParser(parser)
 */
declare class Data extends SerializedType {
    static readonly ZERO_DATA: Data;
    /**
     * Construct Data from bytes
     * @param bytes - Uint8Array containing type ID and data
     */
    constructor(bytes: Uint8Array);
    /**
     * Create Data from various input types
     *
     * @param value - Can be:
     *   - Data instance (returns as-is)
     *   - DataJSON object with 'type' and 'value' fields
     * @returns Data instance
     * @throws Error if value type is not supported
     */
    static from(value: unknown): Data;
    /**
     * Create Data from JSON representation
     *
     * @param json - Object with 'type' and 'value' fields
     * @returns Data instance
     * @throws Error if type is not supported
     */
    static fromJSON(json: DataJSON): Data;
    /**
     * Read Data from a BinaryParser stream
     *
     * @param parser - BinaryParser positioned at the start of Data
     * @returns Data instance
     */
    static fromParser(parser: BinaryParser): Data;
    /**
     * Get the inner SerializedTypeID
     *
     * @returns The inner type ID
     */
    getInnerType(): SerializedTypeID;
    /**
     * Get the string representation of the inner type
     *
     * @returns String name of the type
     */
    getInnerTypeString(): string;
    /**
     * Get the data value
     *
     * @returns The stored data value
     */
    getValue(): DataValue;
    /**
     * Convert to JSON representation
     *
     * @returns JSON object with 'type' and 'value' fields
     */
    toJSON(): DataJSON;
    /**
     * Compare with another Data for equality
     *
     * @param other - Another Data to compare with
     * @returns true if both have the same inner type and data
     */
    equals(other: Data): boolean;
    getSType(): SerializedTypeID;
}
export { Data };
