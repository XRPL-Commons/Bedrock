package abi

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
)

// Generator handles ABI file generation
type Generator struct {
	outputDir string
}

// NewGenerator creates a new ABI generator
func NewGenerator(outputDir string) *Generator {
	return &Generator{outputDir: outputDir}
}

// Generate creates an abi.json file from the parsed ABI
func (g *Generator) Generate(abi *ABI, filename string) (string, error) {
	// Ensure output directory exists
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create output directory: %w", err)
	}

	outputPath := filepath.Join(g.outputDir, filename)

	// Marshal ABI to JSON with pretty formatting
	jsonData, err := json.MarshalIndent(abi, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal ABI: %w", err)
	}

	// Write to file
	if err := os.WriteFile(outputPath, jsonData, 0644); err != nil {
		return "", fmt.Errorf("failed to write ABI file: %w", err)
	}

	return outputPath, nil
}

// GenerateJS creates a JavaScript module exporting the ABI
// This is useful for direct integration with existing JS deployment scripts
func (g *Generator) GenerateJS(abi *ABI, filename string) (string, error) {
	// Ensure output directory exists
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create output directory: %w", err)
	}

	outputPath := filepath.Join(g.outputDir, filename)

	// Marshal ABI to JSON
	jsonData, err := json.MarshalIndent(abi, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal ABI: %w", err)
	}

	// Create JS module content
	jsContent := fmt.Sprintf(`// Auto-generated ABI for %s
// Generated by bedrock quartz

const abi = %s;

module.exports = abi;
`, abi.ContractName, string(jsonData))

	// Write to file
	if err := os.WriteFile(outputPath, []byte(jsContent), 0644); err != nil {
		return "", fmt.Errorf("failed to write JS ABI file: %w", err)
	}

	return outputPath, nil
}

// Validate checks if an ABI is valid
func (g *Generator) Validate(abi *ABI) []error {
	var errors []error

	if abi.ContractName == "" {
		errors = append(errors, fmt.Errorf("contract name is empty"))
	}

	if len(abi.Functions) == 0 {
		errors = append(errors, fmt.Errorf("no functions found in ABI"))
	}

	// Validate each function
	for i, fn := range abi.Functions {
		if fn.Name == "" {
			errors = append(errors, fmt.Errorf("function %d has empty name", i))
		}

		// Check for duplicate parameter names
		paramNames := make(map[string]bool)
		for _, param := range fn.Parameters {
			if param.Name == "" {
				errors = append(errors, fmt.Errorf("function '%s' has parameter with empty name", fn.Name))
			}

			if paramNames[param.Name] {
				errors = append(errors, fmt.Errorf("function '%s' has duplicate parameter name '%s'", fn.Name, param.Name))
			}
			paramNames[param.Name] = true

			if !IsValidType(param.Type) {
				errors = append(errors, fmt.Errorf("function '%s' parameter '%s' has invalid type '%s'", fn.Name, param.Name, param.Type))
			}
		}

		// Validate return type if present
		if fn.Returns != nil && !IsValidType(fn.Returns.Type) {
			errors = append(errors, fmt.Errorf("function '%s' has invalid return type '%s'", fn.Name, fn.Returns.Type))
		}
	}

	return errors
}
