#!/usr/bin/env node

/**
 * XRPL Smart Contract Deployment Module
 *
 * This module handles deploying WASM smart contracts to XRPL networks.
 * It uses the ABI generated by bedrock quartz to construct proper function definitions.
 *
 * Usage: node deploy.js <config-json-path>
 *
 * Config JSON format:
 * {
 *   "wasm_path": "/path/to/contract.wasm",
 *   "abi_path": "/path/to/abi.json",
 *   "network_url": "wss://alphanet.xrpl.org",
 *   "wallet_seed": "sXXX..." (optional),
 *   "faucet_url": "https://faucet..." (optional),
 *   "fee": "100000000" (optional, default 100 XRP),
 *   "verbose": true (optional)
 * }
 *
 * Output JSON format:
 * {
 *   "success": true,
 *   "data": {
 *     "txHash": "...",
 *     "walletAddress": "...",
 *     "walletSeed": "...",
 *     "contractAccount": "...",
 *     "contractIndex": "...",
 *     "validated": true
 *   }
 * }
 */

const xrpl = require('@transia/xrpl');
const fs = require('fs');
const path = require('path');

/**
 * Extract exported function names from WASM binary
 */
function extractWasmFunctions(wasmBytes) {
  let offset = 0;

  // Check WASM magic number
  if (wasmBytes.readUInt32LE(0) !== 0x6d736100) {
    throw new Error('Invalid WASM file: magic number mismatch');
  }
  offset += 4;

  // Check version
  if (wasmBytes.readUInt32LE(4) !== 0x01) {
    throw new Error('Invalid WASM file: unsupported version');
  }
  offset += 4;

  let exportedFunctions = [];

  // Parse sections
  while (offset < wasmBytes.length) {
    const sectionId = wasmBytes[offset++];
    const sectionSize = readVarUInt32(wasmBytes, offset);
    offset = sectionSize.nextOffset;
    const sectionEnd = offset + sectionSize.value;

    if (sectionId === 7) {
      // Export section
      const count = readVarUInt32(wasmBytes, offset);
      offset = count.nextOffset;

      for (let i = 0; i < count.value; i++) {
        const nameLen = readVarUInt32(wasmBytes, offset);
        offset = nameLen.nextOffset;

        const name = wasmBytes.toString('utf8', offset, offset + nameLen.value);
        offset += nameLen.value;

        const kind = wasmBytes[offset++];
        const index = readVarUInt32(wasmBytes, offset);
        offset = index.nextOffset;

        if (kind === 0) {
          exportedFunctions.push(name);
        }
      }
    } else {
      offset = sectionEnd;
    }
  }

  return exportedFunctions;
}

function readVarUInt32(buffer, offset) {
  let result = 0;
  let shift = 0;
  let byte;
  let nextOffset = offset;

  do {
    byte = buffer[nextOffset++];
    result |= (byte & 0x7f) << shift;
    shift += 7;
  } while (byte & 0x80);

  return { value: result, nextOffset };
}

/**
 * Build Functions array from ABI with parameter definitions
 */
function buildFunctionsFromABI(abi, exportedFunctions) {
  const functions = [];

  for (const fn of abi.functions) {
    // Only include functions that are actually exported in WASM
    if (!exportedFunctions.includes(fn.name)) {
      continue;
    }

    // Build Parameters array from ABI
    const parameters = fn.parameters.map(param => ({
      Parameter: {
        ParameterName: Buffer.from(param.name).toString('hex').toUpperCase(),
        ParameterType: {
          type: param.type
        }
      }
    }));

    functions.push({
      Function: {
        FunctionName: Buffer.from(fn.name).toString('hex').toUpperCase(),
        Parameters: parameters.length > 0 ? parameters : undefined
      }
    });
  }

  return functions;
}

/**
 * Deploy contract to XRPL network
 */
async function deployContract(config) {
  const { wasm_path, abi_path, network_url, wallet_seed, faucet_url, fee, verbose } = config;

  const log = verbose ? console.error.bind(console) : () => {};

  log('Deploying contract to XRPL...\n');

  const client = new xrpl.Client(network_url);

  try {
    await client.connect();
    log('✓ Connected to network');

    // Create or restore wallet
    const wallet = wallet_seed
      ? xrpl.Wallet.fromSeed(wallet_seed)
      : xrpl.Wallet.generate();

    log('\nWallet:');
    log('  Address:', wallet.address);
    log('  Seed:', wallet.seed);

    // Read WASM file
    if (!fs.existsSync(wasm_path)) {
      throw new Error(`WASM file not found: ${wasm_path}`);
    }

    const wasmBytes = fs.readFileSync(wasm_path);
    const wasmHex = wasmBytes.toString('hex').toUpperCase();

    log(`\nContract size: ${wasmBytes.length} bytes`);

    // Extract functions from WASM
    const exportedFunctions = extractWasmFunctions(wasmBytes);
    log(`Found ${exportedFunctions.length} exported function(s):`);
    exportedFunctions.forEach((name, idx) => {
      log(`  ${idx + 1}. ${name}`);
    });

    // Load and validate ABI
    let Functions;
    if (abi_path && fs.existsSync(abi_path)) {
      log(`\nLoading ABI from: ${abi_path}`);
      const abiContent = fs.readFileSync(abi_path, 'utf8');
      const abi = JSON.parse(abiContent);

      log(`ABI contract: ${abi.contract_name}`);
      log(`ABI functions: ${abi.functions.length}`);

      // Build Functions array with parameter definitions from ABI
      Functions = buildFunctionsFromABI(abi, exportedFunctions);

      log('\nFunction definitions:');
      Functions.forEach((f, idx) => {
        const funcName = Buffer.from(f.Function.FunctionName, 'hex').toString('utf8');
        log(`  ${idx + 1}. ${funcName}`);
        if (f.Function.Parameters) {
          f.Function.Parameters.forEach(p => {
            const paramName = Buffer.from(p.Parameter.ParameterName, 'hex').toString('utf8');
            log(`      - ${paramName}: ${p.Parameter.ParameterType.type}`);
          });
        }
      });
    } else {
      // Fallback: no ABI, just function names
      log('\nNo ABI provided, deploying with function names only');
      Functions = exportedFunctions.map(name => ({
        Function: {
          FunctionName: Buffer.from(name).toString('hex').toUpperCase()
        }
      }));
    }

    // Check balance
    const balance = await client.getXrpBalance(wallet.address);
    log(`\nWallet balance: ${balance} XRP`);

    if (parseFloat(balance) === 0) {
      log('Warning: Wallet not funded, deployment will likely fail');
    }

    // Create ContractCreate transaction
    log('\nSubmitting contract creation transaction...');

    const tx = {
      TransactionType: 'ContractCreate',
      Account: wallet.address,
      ContractCode: wasmHex,
      Functions: Functions,
      Fee: fee || '100000000', // 100 XRP default
    };

    const prepared = await client.autofill(tx);
    const signed = wallet.sign(prepared);

    log('Transaction ID:', signed.hash);

    const result = await client.submitAndWait(signed.tx_blob);

    log('\n✓ Contract deployed successfully!');

    // Extract contract account from result
    const meta = result.result.meta;
    let contractAccount = null;
    let contractIndex = null;

    if (meta?.AffectedNodes) {
      for (const node of meta.AffectedNodes) {
        if (node.CreatedNode?.LedgerEntryType === 'Contract') {
          contractIndex = node.CreatedNode.LedgerIndex;
          log('\nContract Ledger Index:', contractIndex);
        }
      }
    }

    await client.disconnect();
    log('\n✓ Disconnected');

    // Output deployment info as clean JSON to stdout
    const deploymentInfo = {
      success: true,
      data: {
        txHash: signed.hash,
        walletAddress: wallet.address,
        walletSeed: wallet.seed,
        contractAccount: contractAccount,
        contractIndex: contractIndex,
        validated: result.result.validated,
        meta: meta
      }
    };

    console.log(JSON.stringify(deploymentInfo));
    return deploymentInfo;

  } catch (error) {
    if (client.isConnected()) {
      await client.disconnect();
    }

    // Output error as JSON
    const errorResult = {
      success: false,
      error: error.message,
      details: error.data ? JSON.stringify(error.data) : error.stack
    };

    console.log(JSON.stringify(errorResult));
    process.exit(1);
  }
}

// CLI interface
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.length < 1) {
    console.error(`
Usage: node deploy.js <config-json-path>

The config JSON file should contain:
{
  "wasm_path": "/path/to/contract.wasm",
  "abi_path": "/path/to/abi.json",
  "network_url": "wss://alphanet.xrpl.org",
  "wallet_seed": "sXXX..." (optional),
  "faucet_url": "https://faucet..." (optional),
  "fee": "100000000" (optional),
  "verbose": true (optional)
}

Output is pure JSON to stdout.
`);
    process.exit(1);
  }

  const configPath = args[0];

  if (!fs.existsSync(configPath)) {
    const errorResult = {
      success: false,
      error: `Config file not found: ${configPath}`,
      details: 'Please provide a valid config JSON file path'
    };
    console.log(JSON.stringify(errorResult));
    process.exit(1);
  }

  try {
    const configContent = fs.readFileSync(configPath, 'utf8');
    const config = JSON.parse(configContent);
    deployContract(config);
  } catch (error) {
    const errorResult = {
      success: false,
      error: 'Failed to load config',
      details: error.message
    };
    console.log(JSON.stringify(errorResult));
    process.exit(1);
  }
}

module.exports = { deployContract, buildFunctionsFromABI };
